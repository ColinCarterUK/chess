// BP 7.1.6 content: Component syschar: 3 persistence-version: 7.1.6

within lichess_bot::components is

	component Engine is
		
		package bot;
		package functions;
		package games;
		
		required port chess implements LichessAPI is

			@dialect("oal");
			message abort(game_id: in string) return Result to provider;

			@dialect("oal");
			message acceptChallenge(challenge_id: in string) return Result to provider;

			@dialect("oal");
			message chat(game_id: in string, text: in string, room: in Room) return Result to provider;

			@dialect("oal");
			message createChallenge(user: in string, rated: in boolean, clock_limit: in integer, clock_increment: in integer, color: in Color, variant: in Variant, fen: in string) return Result to provider;

			@dialect("oal");
			message declineChallenge(challenge_id: in string, reason: in DeclineReason) return Result to provider;

			@dialect("oal");
			message draw(game_id: in string, accept: in boolean) return Result to provider;

			@dialect("oal");
			message getUser() return User to provider;

			@dialect("oal");
			message move(game_id: in string, move: in string) return Result to provider;

			@dialect("oal");
			message resign(game_id: in string) return Result to provider;

			@dialect("oal");
			message takeback(game_id: in string, accept: in boolean) return Result to provider;

			@dialect("oal");
			message challenge(challenge: in Challenge) from provider is
				@noparse
				LOG::LogInfo(message:"Received challenge: " + param.challenge.id);
				c = param.challenge;
				
				select any bot from instances of Bot;
				
				// handle incoming challenges
				if c.challenger.id != bot.user.id then
				
					accept_challenge = true;
					reason = DeclineReason::GENERIC;
				
					// only accept the challenge if not at the max number of active games
					// default to one game at a time
					max_games = PROP::getInteger(properties: bot.config, name: "max_games", default_value: 1);
					select many games from instances of Game where (selected.game_state.status == GameStatus::CREATED or selected.game_state.status == GameStatus::STARTED);
					if cardinality games >= max_games then
							accept_challenge = false;
							reason = DeclineReason::LATER;
					end if;
				
					// only accept unrated standard games
					if c.rated then
							accept_challenge = false;
							reason = DeclineReason::CASUAL;
					end if;
				
					// only accept standard games starting from the standard start position
					if c.variant != Variant::STANDARD or not (c.initialFen == "" or c.initialFen == "startpos") then
							accept_challenge = false;
							reason = DeclineReason::STANDARD;
					end if;
				
					// send the accept or decline message
					if accept_challenge then
							result = chess::acceptChallenge(challenge_id:c.id);
					else
							result = chess::declineChallenge(challenge_id:c.id, reason:reason);
					end if;
					
				else
					
					LOG::LogInfo(message: "Watch outgoing challenge at: " + c.url );
					if PROP::getBoolean(properties: bot.config, name: "auto_open_challenge_url", default_value: false) then
						ARCH::openURL(url:c.url);
					end if;
				
				end if;
				@endnoparse
			end message;

			@dialect("oal");
			message challengeCanceled(challenge: in Challenge) from provider is
				@noparse
				LOG::LogInfo(message:"Challenge canceled: " + param.challenge.id);
				@endnoparse
			end message;

			@dialect("oal");
			message chatLine(game_id: in string, username: in string, text: in string, room: in Room) from provider is
				@noparse
				LOG::LogInfo(message:"Chat line: " + param.game_id + ", " + param.username + ": " + param.text);
				
				// TODO make the maia1 bot play faster
				if (param.username == "maia1" and param.text == "Hi levifish, I'm currently taking my time like a human. If you type 'go' or 'fast' in the chat I'll play faster. gl hf") then
					r = chess::chat(game_id:param.game_id, room:Room::PLAYER, text:"go");
				end if;
				
				select any game from instances of Game where selected.id == param.game_id;
				if not empty game then
				
					// handle takeback proposals
					if param.username == "lichess" and param.room == Room::PLAYER and param.text == "Takeback sent" then
						game.handle_takeback_proposal();
					end if;
				
					// handle draw offers
					if param.username == "lichess" and param.room == Room::PLAYER and
						((game.color == Color::WHITE and param.text == "Black offers draw") or
						(game.color == Color::BLACK and param.text == "White offers draw")) then
						game.handle_draw_offer();
					end if;
				
				end if;
				@endnoparse
			end message;

			@dialect("oal");
			message connect(properties: in Properties) to provider;

			@dialect("oal");
			message error(error: in APIException) from provider is
				@noparse
				LOG::LogFailure(message:"API error: " +  param.error.error);
				ARCH::shutdown();
				@endnoparse
			end message;

			@dialect("oal");
			message gameFinish(game_event: in GameEventInfo) from provider is
				@noparse
				LOG::LogInfo(message:"Game finish: " + param.game_event.id);
				// r = chess::chat(game_id:param.game_event.id, text:"Gg", room:Room::PLAYER);
				@endnoparse
			end message;

			@dialect("oal");
			message gameFull(game: in Game) from provider is
				@noparse
				LOG::LogInfo(message:"Game full: " + param.game.id);
				g = param.game;
				
				// find/create the game
				select any game from instances of Game where selected.id == g.id;
				if empty game then
					create object instance game of Game;
					game.id = g.id;
				end if;
				
				// set color for the game
				bot = chess::getUser();
				if g.white.name == bot.username then
					game.color = Color::WHITE;
				else
					game.color = Color::BLACK;
				end if;
				
				// update the game state
				game.game_state = g.gameState;
				
				// TODO
				if not (game.game_state.status == GameStatus::CREATED or game.game_state.status == GameStatus::STARTED) then
						generate Game2:'game over'(status:game.game_state.status) to game;
				else
					if game.is_our_turn() then
						generate Game4:'ready to play' to game;
					else
						generate Game1:'waiting on move' to game;
					end if;
				end if;
				@endnoparse
			end message;

			@dialect("oal");
			message gameStart(game_event: in GameEventInfo) from provider is
				@noparse
				LOG::LogInfo(message:"Game start: " + param.game_event.id);
				// r = chess::chat(game_id:param.game_event.id, text:"Good luck!", room:Room::PLAYER);
				g = param.game_event;
				
				// find/create a game
				select any game from instances of Game where selected.id == g.id;
				if empty game then
					create object instance game of Game;
					game.id = g.id;
				end if;
				@endnoparse
			end message;

			@dialect("oal");
			message gameState(game_id: in string, game_state: in GameState) from provider is
				@noparse
				LOG::LogInfo(message:"Game state: " + param.game_id);
				g = param.game_state;
				select any game from instances of Game where selected.id == param.game_id;
				if not empty game then
					game.game_state = g;
					if not (game.game_state.status == GameStatus::CREATED or game.game_state.status == GameStatus::STARTED) then
							generate Game2:'game over'(status:game.game_state.status) to game;
					else
						if game.is_our_turn() then
							generate Game4:'ready to play' to game;
						else
							generate Game1:'waiting on move' to game;
						end if;
					end if;
				else
					// TODO handle this error case
				end if;
				@endnoparse
			end message;

			@dialect("oal");
			message opponentGone(game_id: in string) from provider is
				@noparse
				LOG::LogInfo(message:"Opponent gone: " + param.game_id);
				@endnoparse
			end message;

		end port;

		provided port inst implements Instrumentation is

			@dialect("oal");
			@message_num(1);
			message init() to provider is
				@noparse
				::init();
				@endnoparse
			end message;

		end port;

	end component;

end;
