= xtUML Chess as C

xtUML Project Analysis Note

== 1 Abstract

This note documents a path to running an xtUML model + lichess.org
application as C generated from MC-3020.

== 2 Introduction and Background

<<dr-2>> is a git repository for an xtUML application that can play chess
through an API to <<dr-3,lichess.org>>.  The repository contains support
of Verifier and the Ciera model compiler.

It would be interesting to compare the performance of Ciera Java with
MC-3020 C in move selection.

== 3 Requirements

=== 3.1 Provide Lichess API

A Lichess API exists for Java and integrates with Java generated from
Ciera.  It also works with BridgePoint Verifier which is also a Java
application.  Either natively in C or leveraging the Lichess Java API,
supply support to communicate with the chess interface published by
<<dr-3, lichess.org>>.

== 4 Analysis

=== 4.1 Realized EEs

Two external entities (EEs) have been written for the Java support of the
Lichess API.  `PROP` and `ChessLib` provide utility routines to facilitate
communication through the Lichess API.

==== 4.1.1 `PROP`

`PROP` provides a wrapper around `java.util.Properties`.  A properties
file is used to carry user ID and authentication information.  `PROP`
supports reading the properties file and passing a Properties object.
Properties are a distincly Java notion.

For C, a couple of ideas come to mind on how to go with this.

. Read and parse the properties file in C.
  ** This has been done before.  `Poco` and `log4cplus` support reading
     and parsing Java-ish Properties files.
. Switch to a different format for the project configuration values.
  ** The first format to switch to is JSON.
. Skip it and hand edit a file with needed data.

=== 4.2 Sequence of Game

. ::init()
  .. Load configuration.  // could be hard-coded
  .. send chess::connect(config) // can be simulated by dropping JSON message to API
. recv chess::connected()
  .. send chess::account() to get User ID.
  .. ::send_challenge()
     ... send chess::createChallenge(...)
. recv chess::GameStart(game_event)
  .. create ActiveGame
. recv chess::GameState(game_id,game_state)
  .. take turn or wait


== 5 Work Required

=== 5.1 Model, Realized Code and Model Compiler Changes

. Implement the `ARCH` EE (for the openURL bridge).
. Implement the `PROP` EE, perhaps switching both Java and C to using JSON.
  ** Consider skipping and using an edited JSON file as a message.
. Implement the `ChessLib` EE.
. Explore the support for passing arrays of strings in MC-3020.
  ** With TagInstanceLoading turned on, we do get transient string array
     initializers.
  ** MC-3020 does not support assigning an array to an array.
     *** e.g. `legal_moves = ChessLib::legal_moves(fen:fen)`
. Explore the support variable length arrays in MC-3020.
  ** How can we work around this?
     *** special EE?
     *** Use fixed length arrays with a separate length value?
. Implement a communication channel between the Lichess component as Java
  and the Engine component as C.
. Find a JSON parser for C (starting with the same one we started with in
  early Munin).
  ** Use <<dr-4, JSMN (Jasmine)>>.

=== 5.2 File Communication

* Consider POSIX threading to be more CPU friendly.
  ** Turn on POSIX threading in `system.mark`.
  ** Modify TIM_bridge.c to wake in 1 second if there are no ticking
     timers.
  ** Print from sys_user_co.c UserBackgroundCallout to prove it alive.
* Periodically (once per second to start with) check for a message file.
* message files will be alphanumerically ordered.

== 6 Acceptance Test

. Generate code from xtuml/chess using MC-3020.
. Compile it.
. Run it.
. See it play.

== 7 Document References

. [[dr-1]] https://support.onefact.net/issues/12845[12845 - C code generation for the chess model]
. [[dr-2]] https://github.com/xtuml/chess[xtUML Chess Playing Robot]
. [[dr-3]] https://lichess.org/[lichess.org]
. [[dr-4]] https://github.com/zserge/jsmn[JSMN - Simple #include-only JSON Parser]

---

This work is licensed under the Creative Commons CC0 License

---
